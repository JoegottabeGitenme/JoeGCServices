# Default values for weather-wms

# Global settings
global:
  imageRegistry: ""
  imagePullSecrets: []

# API Service
api:
  replicaCount: 2
  image:
    repository: weather-wms/wms-api
    tag: latest
    pullPolicy: IfNotPresent
  
  service:
    type: ClusterIP
    port: 8080
  
  ingress:
    enabled: true
    className: nginx
    annotations:
      nginx.ingress.kubernetes.io/proxy-body-size: "100m"
    hosts:
      - host: wms.local
        paths:
          - path: /
            pathType: Prefix
    tls: []

  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 100m
      memory: 256Mi

  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70

  env:
    LOG_LEVEL: info

# Dashboard (web UI)
dashboard:
  enabled: true
  image:
    repository: weather-wms/dashboard
    tag: latest
    pullPolicy: IfNotPresent
  
  service:
    type: ClusterIP
    port: 8000
  
  resources:
    limits:
      cpu: 100m
      memory: 128Mi
    requests:
      cpu: 50m
      memory: 64Mi

# Ingester
ingester:
  enabled: true
  
  # Run as CronJob or Deployment
  mode: deployment  # or "cronjob"
  
  image:
    repository: weather-wms/ingester
    tag: latest
    pullPolicy: IfNotPresent
  
  # CronJob settings (if mode: cronjob)
  schedule: "*/15 * * * *"  # Every 15 minutes
  
  resources:
    limits:
      cpu: 2000m
      memory: 4Gi
    requests:
      cpu: 100m
      memory: 2Gi

  env:
    LOG_LEVEL: info
    PARALLEL_DOWNLOADS: "4"

  # Models to ingest
  models:
    gfs:
      enabled: true
      pollInterval: 3600
    hrrr:
      enabled: true
      pollInterval: 3600

# Downloader - handles weather data downloads with resumable downloads
downloader:
  enabled: true
  
  # Run as CronJob or Deployment
  mode: deployment  # or "cronjob"
  
  image:
    repository: weather-wms/downloader
    tag: latest
    pullPolicy: IfNotPresent
  
  # CronJob settings (if mode: cronjob)
  schedule: "0 * * * *"  # Every hour
  
  resources:
    limits:
      cpu: 1000m
      memory: 1Gi
    requests:
      cpu: 100m
      memory: 256Mi

  # Persistent storage for downloads and state
  persistence:
    enabled: true
    downloads:
      size: 100Gi
      storageClass: ""
    state:
      size: 1Gi
      storageClass: ""

  env:
    LOG_LEVEL: info
    MAX_CONCURRENT: "4"
    MAX_RETRIES: "5"

# Redis configuration
redis:
  enabled: true
  architecture: standalone
  auth:
    enabled: false
  master:
    persistence:
      enabled: true
      size: 8Gi
  replica:
    replicaCount: 0

# PostgreSQL configuration
postgresql:
  enabled: true
  auth:
    username: weatherwms
    password: weatherwms
    database: weatherwms
  primary:
    persistence:
      enabled: true
      size: 10Gi

# MinIO configuration
minio:
  enabled: true
  mode: standalone
  auth:
    rootUser: minioadmin
    rootPassword: minioadmin
  persistence:
    enabled: true
    size: 50Gi
  defaultBuckets: "weather-data"

# Shared configuration
config:
  # S3/MinIO settings (auto-configured from minio chart if enabled)
  s3:
    endpoint: ""  # Leave empty to auto-configure
    bucket: weather-data
    region: us-east-1
  
  # Database settings (auto-configured from postgresql chart if enabled)
  database:
    url: ""  # Leave empty to auto-configure
    poolSize: "50"
  
  # Redis settings (auto-configured from redis chart if enabled)  
  redis:
    url: ""  # Leave empty to auto-configure
  
  # Logging
  logging:
    level: info
    backtrace: "1"
  
  # Performance tuning
  performance:
    workerThreads: "8"
  
  # GRIB data cache
  cache:
    grib:
      enabled: true
      size: "500"
    l1:
      enabled: true
      size: "10000"
      ttlSecs: "300"
  
  # Tile prefetching
  prefetch:
    enabled: true
    rings: "2"
    minZoom: "3"
    maxZoom: "12"
  
  # Cache warming (pre-render tiles at startup)
  cacheWarming:
    enabled: false  # Disable for faster startup in dev
    maxZoom: "4"
    hours: "0"
    layers: "gfs_TMP:temperature"
    concurrency: "10"

# ServiceAccount
serviceAccount:
  create: true
  annotations: {}
  name: ""

# Pod security context
podSecurityContext:
  fsGroup: 1000

securityContext:
  runAsNonRoot: true
  runAsUser: 1000

# Node selectors
nodeSelector: {}

tolerations: []

affinity: {}
