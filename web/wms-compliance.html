<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WMS 1.3.0 OGC Compliance Tests</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css">
    <link rel="stylesheet" href="style.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e5e7eb;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
        }

        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .back-link {
            color: #60a5fa;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .back-link:hover {
            color: #93c5fd;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #f3f4f6;
        }

        .header-badge {
            background: rgba(34, 197, 94, 0.2);
            border: 1px solid rgba(34, 197, 94, 0.4);
            color: #4ade80;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        /* Summary Bar */
        .summary-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .summary-stats {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .stat-value {
            font-size: 1.25rem;
            font-weight: 600;
            color: #f3f4f6;
        }

        .stat-value.good {
            color: #4ade80;
        }

        .stat-value.warning {
            color: #fbbf24;
        }

        .stat-value.bad {
            color: #f87171;
        }

        .stat-label {
            color: #9ca3af;
            font-size: 0.85rem;
        }

        .summary-actions {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .filter-select, .action-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e5e7eb;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.85rem;
            cursor: pointer;
        }

        .filter-select:hover, .action-btn:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .action-btn.primary {
            background: rgba(59, 130, 246, 0.3);
            border-color: rgba(59, 130, 246, 0.5);
        }

        .action-btn.primary:hover {
            background: rgba(59, 130, 246, 0.4);
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Controls Bar */
        .controls-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .layer-nav {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .nav-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e5e7eb;
            width: 36px;
            height: 36px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
        }

        .nav-btn:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.2);
        }

        .nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .layer-info {
            text-align: center;
        }

        .layer-name {
            font-weight: 600;
            color: #f3f4f6;
            font-size: 1.1rem;
        }

        .layer-title {
            color: #9ca3af;
            font-size: 0.85rem;
        }

        .layer-index {
            color: #6b7280;
            font-size: 0.8rem;
        }

        .dimension-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .dimension-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .dimension-label {
            color: #9ca3af;
            font-size: 0.8rem;
            text-transform: uppercase;
        }

        .dimension-select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e5e7eb;
            padding: 0.4rem 0.75rem;
            border-radius: 4px;
            font-size: 0.85rem;
            max-width: 200px;
        }

        /* Main Content */
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .map-panel {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            overflow: hidden;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel-title {
            font-weight: 500;
            color: #f3f4f6;
        }

        .panel-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }

        .status-icon {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .status-icon.ok {
            background: #4ade80;
            box-shadow: 0 0 6px rgba(74, 222, 128, 0.5);
        }

        .status-icon.error {
            background: #f87171;
            box-shadow: 0 0 6px rgba(248, 113, 113, 0.5);
        }

        .status-icon.loading {
            background: #fbbf24;
            animation: pulse 1s infinite;
        }

        .status-icon.untested {
            background: #6b7280;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        .status-text {
            color: #9ca3af;
        }

        .status-text.ok {
            color: #4ade80;
        }

        .status-text.error {
            color: #f87171;
        }

        #map {
            height: 350px;
            background: #1f2937;
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
        }

        .info-content {
            flex: 1;
            padding: 1rem;
            overflow: auto;
            max-height: 350px;
        }

        .info-json {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.8rem;
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            border-radius: 4px;
            white-space: pre-wrap;
            word-break: break-all;
            color: #a5f3fc;
        }

        .info-placeholder {
            color: #6b7280;
            text-align: center;
            padding: 2rem;
        }

        .error-details {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 4px;
            padding: 1rem;
            margin-top: 0.5rem;
        }

        .error-summary {
            color: #f87171;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .error-full {
            margin-top: 0.75rem;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.75rem;
            color: #fca5a5;
            white-space: pre-wrap;
            word-break: break-all;
            display: none;
        }

        .error-details.expanded .error-full {
            display: block;
        }

        /* URL Display */
        .url-display {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        @media (max-width: 900px) {
            .url-display {
                grid-template-columns: 1fr;
            }
        }

        .url-item {
            margin-bottom: 0;
        }

        .url-label {
            color: #9ca3af;
            font-size: 0.8rem;
            margin-bottom: 0.25rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .copy-btn {
            background: none;
            border: none;
            color: #60a5fa;
            cursor: pointer;
            font-size: 0.75rem;
        }

        .copy-btn:hover {
            color: #93c5fd;
        }

        .url-value {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            padding: 0.5rem;
            border-radius: 4px;
            word-break: break-all;
            color: #a5b4fc;
            max-height: 60px;
            overflow-y: auto;
        }

        /* Layer List (for broken filter) */
        .layer-list {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            margin-bottom: 1rem;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .layer-list.visible {
            display: block;
        }

        .layer-list-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            cursor: pointer;
        }

        .layer-list-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .layer-list-item:last-child {
            border-bottom: none;
        }

        .layer-list-name {
            font-size: 0.85rem;
        }

        .layer-list-status {
            font-size: 0.75rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
        }

        .layer-list-status.ok {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }

        .layer-list-status.error {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
        }

        .layer-list-status.untested {
            background: rgba(107, 114, 128, 0.2);
            color: #9ca3af;
        }

        /* Progress indicator for Test All */
        .progress-bar {
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 0.5rem;
            display: none;
        }

        .progress-bar.visible {
            display: block;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            transition: width 0.3s ease;
            width: 0%;
        }

        /* Loading overlay */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Keyboard hint */
        .keyboard-hint {
            text-align: center;
            color: #6b7280;
            font-size: 0.75rem;
            margin-top: 0.5rem;
        }

        kbd {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            padding: 0.1rem 0.4rem;
            font-family: inherit;
        }

        /* OGC Compliance Test Section */
        .ogc-section {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .ogc-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }

        .ogc-header:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .ogc-header-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .ogc-toggle {
            color: #6b7280;
            transition: transform 0.2s;
        }

        .ogc-section.expanded .ogc-toggle {
            transform: rotate(90deg);
        }

        .ogc-title {
            font-weight: 600;
            color: #f3f4f6;
        }

        .ogc-subtitle {
            color: #9ca3af;
            font-size: 0.85rem;
        }

        .ogc-header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .ogc-score {
            font-size: 0.9rem;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-weight: 500;
        }

        .ogc-score.pass {
            background: rgba(34, 197, 94, 0.2);
            color: #4ade80;
        }

        .ogc-score.partial {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }

        .ogc-score.fail {
            background: rgba(239, 68, 68, 0.2);
            color: #f87171;
        }

        .ogc-score.pending {
            background: rgba(107, 114, 128, 0.2);
            color: #9ca3af;
        }

        .ogc-run-btn {
            background: rgba(59, 130, 246, 0.3);
            border: 1px solid rgba(59, 130, 246, 0.5);
            color: #93c5fd;
            padding: 0.4rem 0.75rem;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
        }

        .ogc-run-btn:hover {
            background: rgba(59, 130, 246, 0.4);
        }

        .ogc-run-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .ogc-content {
            display: none;
            padding: 0;
        }

        .ogc-section.expanded .ogc-content {
            display: block;
        }

        .ogc-category {
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .ogc-category:last-child {
            border-bottom: none;
        }

        .ogc-category-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.1);
        }

        .ogc-category-header:hover {
            background: rgba(0, 0, 0, 0.2);
        }

        .ogc-category-left {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .ogc-category-toggle {
            color: #6b7280;
            font-size: 0.75rem;
            transition: transform 0.2s;
        }

        .ogc-category.expanded .ogc-category-toggle {
            transform: rotate(90deg);
        }

        .ogc-category-name {
            font-weight: 500;
            color: #e5e7eb;
            font-size: 0.9rem;
        }

        .ogc-category-count {
            font-size: 0.8rem;
            color: #9ca3af;
        }

        .ogc-category-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .ogc-category-badge {
            font-size: 0.75rem;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
        }

        .ogc-category-badge.pass {
            background: rgba(34, 197, 94, 0.2);
            color: #4ade80;
        }

        .ogc-category-badge.partial {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }

        .ogc-category-badge.fail {
            background: rgba(239, 68, 68, 0.2);
            color: #f87171;
        }

        .ogc-category-badge.pending {
            background: rgba(107, 114, 128, 0.2);
            color: #9ca3af;
        }

        .ogc-tests {
            display: none;
            padding: 0;
        }

        .ogc-category.expanded .ogc-tests {
            display: block;
        }

        .ogc-test {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            padding: 0.6rem 1rem 0.6rem 2.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
            font-size: 0.85rem;
        }

        .ogc-test:last-child {
            border-bottom: none;
        }

        .ogc-test-left {
            flex: 1;
        }

        .ogc-test-id {
            color: #6b7280;
            font-family: monospace;
            font-size: 0.75rem;
        }

        .ogc-test-desc {
            color: #d1d5db;
            margin-top: 0.15rem;
        }

        .ogc-test-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: 1rem;
        }

        .ogc-test-icon {
            font-size: 0.9rem;
        }

        .ogc-test-icon.pass {
            color: #4ade80;
        }

        .ogc-test-icon.fail {
            color: #f87171;
        }

        .ogc-test-icon.pending {
            color: #6b7280;
        }

        .ogc-test-icon.running {
            color: #fbbf24;
            animation: pulse 1s infinite;
        }

        .ogc-test-time {
            color: #6b7280;
            font-size: 0.75rem;
            font-family: monospace;
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .ogc-test-time:hover {
            max-width: none;
            white-space: normal;
            word-break: break-all;
        }

        .ogc-test-error {
            color: #fca5a5;
            font-size: 0.75rem;
            margin-top: 0.25rem;
            font-family: monospace;
        }

        .ogc-test-url {
            display: none;
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.7rem;
            word-break: break-all;
            color: #a5b4fc;
        }

        .ogc-test.show-url .ogc-test-url {
            display: block;
        }

        .ogc-test-url-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.25rem;
        }

        .ogc-test-url-label {
            color: #9ca3af;
            font-size: 0.65rem;
            text-transform: uppercase;
        }

        .ogc-test-url-actions {
            display: flex;
            gap: 0.5rem;
        }

        .ogc-test-url-btn {
            background: none;
            border: none;
            color: #60a5fa;
            cursor: pointer;
            font-size: 0.65rem;
            padding: 0;
        }

        .ogc-test-url-btn:hover {
            color: #93c5fd;
            text-decoration: underline;
        }

        .ogc-test-url-value {
            color: #a5b4fc;
            user-select: all;
        }

        .ogc-test-toggle-url {
            background: none;
            border: none;
            color: #6b7280;
            cursor: pointer;
            font-size: 0.7rem;
            padding: 0.2rem 0.4rem;
            margin-left: 0.5rem;
        }

        .ogc-test-toggle-url:hover {
            color: #9ca3af;
        }

        /* Section divider */
        .section-divider {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin: 1.5rem 0;
            color: #6b7280;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .section-divider::before,
        .section-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
        }

        /* Overall summary bar */
        .ogc-overall {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .ogc-overall-left {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        .ogc-overall-title {
            font-weight: 600;
            color: #f3f4f6;
        }

        .ogc-overall-stats {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .ogc-stat {
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .ogc-stat-value {
            font-weight: 600;
            font-size: 1.1rem;
        }

        .ogc-stat-value.pass {
            color: #4ade80;
        }

        .ogc-stat-value.fail {
            color: #f87171;
        }

        .ogc-stat-value.pending {
            color: #9ca3af;
        }

        .ogc-stat-label {
            color: #9ca3af;
            font-size: 0.8rem;
        }

        .ogc-overall-right {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .ogc-run-all-btn {
            background: rgba(34, 197, 94, 0.3);
            border: 1px solid rgba(34, 197, 94, 0.5);
            color: #4ade80;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.85rem;
            cursor: pointer;
            font-weight: 500;
        }

        .ogc-run-all-btn:hover {
            background: rgba(34, 197, 94, 0.4);
        }

        .ogc-run-all-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
<div class="container">
    <!-- Header -->
    <div class="header">
        <div class="header-left">
            <a href="index.html" class="back-link">← Back to Map</a>
            <h1>WMS 1.3.0 OGC Compliance Tests</h1>
        </div>
        <span class="header-badge">OGC TEAM ENGINE</span>
    </div>

    <!-- OGC Protocol Compliance Overall Summary -->
    <div class="ogc-overall">
        <div class="ogc-overall-left">
            <span class="ogc-overall-title">OGC Protocol Compliance</span>
            <div class="ogc-overall-stats">
                <div class="ogc-stat">
                    <span class="ogc-stat-value pass" id="ogc-pass-count">0</span>
                    <span class="ogc-stat-label">Pass</span>
                </div>
                <div class="ogc-stat">
                    <span class="ogc-stat-value fail" id="ogc-fail-count">0</span>
                    <span class="ogc-stat-label">Fail</span>
                </div>
                <div class="ogc-stat">
                    <span class="ogc-stat-value pending" id="ogc-pending-count">0</span>
                    <span class="ogc-stat-label">Pending</span>
                </div>
            </div>
        </div>
        <div class="ogc-overall-right">
            <button class="ogc-run-all-btn" id="run-all-ogc-btn">Run All OGC Tests</button>
        </div>
    </div>

    <!-- OGC GetCapabilities Tests -->
    <div class="ogc-section" id="ogc-getcapabilities">
        <div class="ogc-header" onclick="toggleOgcSection('ogc-getcapabilities')">
            <div class="ogc-header-left">
                <span class="ogc-toggle">▶</span>
                <span class="ogc-title">GetCapabilities</span>
                <span class="ogc-subtitle">Version negotiation, XML validation, metadata</span>
            </div>
            <div class="ogc-header-right">
                <span class="ogc-score pending" id="ogc-getcapabilities-score">-- / --</span>
            </div>
        </div>
        <div class="ogc-content" id="ogc-getcapabilities-content"></div>
    </div>

    <!-- OGC GetMap Tests -->
    <div class="ogc-section" id="ogc-getmap">
        <div class="ogc-header" onclick="toggleOgcSection('ogc-getmap')">
            <div class="ogc-header-left">
                <span class="ogc-toggle">▶</span>
                <span class="ogc-title">GetMap</span>
                <span class="ogc-subtitle">BBOX, CRS, FORMAT, STYLES, TRANSPARENT, Exceptions</span>
            </div>
            <div class="ogc-header-right">
                <span class="ogc-score pending" id="ogc-getmap-score">-- / --</span>
            </div>
        </div>
        <div class="ogc-content" id="ogc-getmap-content"></div>
    </div>

    <!-- OGC GetFeatureInfo Tests -->
    <div class="ogc-section" id="ogc-getfeatureinfo">
        <div class="ogc-header" onclick="toggleOgcSection('ogc-getfeatureinfo')">
            <div class="ogc-header-left">
                <span class="ogc-toggle">▶</span>
                <span class="ogc-title">GetFeatureInfo</span>
                <span class="ogc-subtitle">Query parameters, exceptions, formats</span>
            </div>
            <div class="ogc-header-right">
                <span class="ogc-score pending" id="ogc-getfeatureinfo-score">-- / --</span>
            </div>
        </div>
        <div class="ogc-content" id="ogc-getfeatureinfo-content"></div>
    </div>

    <!-- OGC Dimensions Tests -->
    <div class="ogc-section" id="ogc-dimensions">
        <div class="ogc-header" onclick="toggleOgcSection('ogc-dimensions')">
            <div class="ogc-header-left">
                <span class="ogc-toggle">▶</span>
                <span class="ogc-title">Dimensions</span>
                <span class="ogc-subtitle">TIME, ELEVATION, custom dimensions</span>
            </div>
            <div class="ogc-header-right">
                <span class="ogc-score pending" id="ogc-dimensions-score">-- / --</span>
            </div>
        </div>
        <div class="ogc-content" id="ogc-dimensions-content"></div>
    </div>

    <!-- Section Divider -->
    <div class="section-divider">Layer Coverage Tests</div>

    <!-- Summary Bar -->
    <div class="summary-bar">
        <div class="summary-stats">
            <div class="stat-item">
                <span class="stat-value" id="working-count">0</span>
                <span class="stat-label">Working</span>
            </div>
            <div class="stat-item">
                <span class="stat-value bad" id="broken-count">0</span>
                <span class="stat-label">Broken</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="untested-count">0</span>
                <span class="stat-label">Untested</span>
            </div>
            <div class="stat-item">
                <span class="stat-value good" id="percent-working">--%</span>
                <span class="stat-label">of Tested</span>
            </div>
        </div>
        <div class="summary-actions">
            <select class="filter-select" id="filter-select">
                <option value="all">Show All</option>
                <option value="working">Working Only</option>
                <option value="broken">Broken Only</option>
                <option value="untested">Untested Only</option>
            </select>
            <button class="action-btn primary" id="test-all-btn">Test All Layers</button>
        </div>
        <div class="progress-bar" id="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
    </div>

    <!-- Layer List (shown when filter active) -->
    <div class="layer-list" id="layer-list"></div>

    <!-- Controls Bar -->
    <div class="controls-bar">
        <div class="layer-nav">
            <button class="nav-btn" id="prev-btn" title="Previous layer (←)">◀</button>
            <div class="layer-info">
                <div class="layer-name" id="layer-name">Loading...</div>
                <div class="layer-title" id="layer-title"></div>
                <div class="layer-index" id="layer-index"></div>
            </div>
            <button class="nav-btn" id="next-btn" title="Next layer (→)">▶</button>
        </div>
        <div class="dimension-controls" id="dimension-controls">
            <div class="dimension-group">
                <span class="dimension-label">Style:</span>
                <select class="dimension-select" id="style-select"></select>
            </div>
            <!-- Dynamic dimension selects will be added here -->
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <div class="map-panel">
            <div class="panel-header">
                <span class="panel-title">GetMap Response</span>
                <div class="panel-status" id="getmap-status">
                    <span class="status-icon untested"></span>
                    <span class="status-text">Not tested</span>
                </div>
            </div>
            <div id="map"></div>
        </div>
        <div class="info-panel">
            <div class="panel-header">
                <span class="panel-title">GetFeatureInfo Response</span>
                <div class="panel-status" id="getfeatureinfo-status">
                    <span class="status-icon untested"></span>
                    <span class="status-text">Not tested</span>
                </div>
            </div>
            <div class="info-content" id="info-content">
                <div class="info-placeholder">Select a layer to test</div>
            </div>
        </div>
    </div>

    <!-- URL Display -->
    <div class="url-display">
        <div class="url-item">
            <div class="url-label">
                <span>GetMap URL</span>
                <button class="copy-btn" onclick="copyUrl('getmap-url')">Copy</button>
            </div>
            <div class="url-value" id="getmap-url">-</div>
        </div>
        <div class="url-item">
            <div class="url-label">
                <span>GetFeatureInfo URL</span>
                <button class="copy-btn" onclick="copyUrl('getfeatureinfo-url')">Copy</button>
            </div>
            <div class="url-value" id="getfeatureinfo-url">-</div>
        </div>
    </div>

    <div class="keyboard-hint">
        Use <kbd>←</kbd> <kbd>→</kbd> to navigate layers, <kbd>Space</kbd> to re-test
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
<script>
    // API URL detection
    const API_BASE = window.location.port === '8000' ? 'http://localhost:8080' : '';

    // ============================================================
    // OGC TEAM ENGINE COMPLIANCE TESTS
    // ============================================================

    // Test definitions organized by category
    const OGC_TESTS = {
        getcapabilities: {
            name: 'GetCapabilities',
            tests: [
                {
                    id: 'caps-version-no-version',
                    desc: 'GetCapabilities without VERSION returns >= 1.3.0',
                    run: async () => {
                        const url = `${API_BASE}/wms?SERVICE=WMS&REQUEST=GetCapabilities`;
                        const resp = await fetch(url);
                        const text = await resp.text();
                        // Match WMS_Capabilities version attribute specifically (not XML declaration)
                        const match = text.match(/WMS_Capabilities[^>]*version="([^"]+)"/);
                        if (!match) throw new Error('No WMS_Capabilities version attribute found');
                        const version = match[1];
                        if (parseFloat(version) < 1.3) throw new Error(`Version ${version} < 1.3.0`);
                        return {version, url};
                    }
                },
                {
                    id: 'caps-version-1.3.0',
                    desc: 'GetCapabilities with VERSION=1.3.0 returns 1.3.0',
                    run: async () => {
                        const url = `${API_BASE}/wms?SERVICE=WMS&REQUEST=GetCapabilities&VERSION=1.3.0`;
                        const resp = await fetch(url);
                        const text = await resp.text();
                        // Match WMS_Capabilities version attribute specifically (not XML declaration)
                        const match = text.match(/WMS_Capabilities[^>]*version="([^"]+)"/);
                        if (!match) throw new Error('No WMS_Capabilities version attribute found');
                        if (match[1] !== '1.3.0') throw new Error(`Expected 1.3.0, got ${match[1]}`);
                        return {version: match[1], url};
                    }
                },
                {
                    id: 'caps-format-default',
                    desc: 'GetCapabilities without FORMAT returns text/xml',
                    run: async () => {
                        const url = `${API_BASE}/wms?SERVICE=WMS&REQUEST=GetCapabilities&VERSION=1.3.0`;
                        const resp = await fetch(url);
                        const ct = resp.headers.get('content-type') || '';
                        if (!ct.includes('text/xml') && !ct.includes('application/xml')) {
                            throw new Error(`Expected XML, got ${ct}`);
                        }
                        return {contentType: ct, url};
                    }
                },
                {
                    id: 'caps-xml-valid',
                    desc: 'GetCapabilities returns valid XML',
                    run: async () => {
                        const url = `${API_BASE}/wms?SERVICE=WMS&REQUEST=GetCapabilities&VERSION=1.3.0`;
                        const resp = await fetch(url);
                        const text = await resp.text();
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(text, 'text/xml');
                        const parseError = doc.querySelector('parsererror');
                        if (parseError) throw new Error('XML parse error');
                        return {valid: true, url};
                    }
                },
                {
                    id: 'caps-has-wms-capabilities',
                    desc: 'Response contains WMS_Capabilities root element',
                    run: async () => {
                        const url = `${API_BASE}/wms?SERVICE=WMS&REQUEST=GetCapabilities&VERSION=1.3.0`;
                        const resp = await fetch(url);
                        const text = await resp.text();
                        if (!text.includes('WMS_Capabilities')) throw new Error('Missing WMS_Capabilities element');
                        return {found: true, url};
                    }
                },
                {
                    id: 'caps-has-getmap-format',
                    desc: 'Advertises image/png for GetMap',
                    run: async () => {
                        const url = `${API_BASE}/wms?SERVICE=WMS&REQUEST=GetCapabilities&VERSION=1.3.0`;
                        const resp = await fetch(url);
                        const text = await resp.text();
                        if (!text.includes('<Format>image/png</Format>')) throw new Error('image/png not advertised');
                        return {format: 'image/png', url};
                    }
                },
                {
                    id: 'caps-has-exception-format',
                    desc: 'Advertises XML exception format',
                    run: async () => {
                        const url = `${API_BASE}/wms?SERVICE=WMS&REQUEST=GetCapabilities&VERSION=1.3.0`;
                        const resp = await fetch(url);
                        const text = await resp.text();
                        if (!text.includes('<Format>XML</Format>') && !text.includes('Exception')) {
                            throw new Error('XML exception format not found');
                        }
                        return {found: true, url};
                    }
                },
                {
                    id: 'caps-layers-have-crs',
                    desc: 'All named layers have at least one CRS',
                    run: async () => {
                        const url = `${API_BASE}/wms?SERVICE=WMS&REQUEST=GetCapabilities&VERSION=1.3.0`;
                        const resp = await fetch(url);
                        const text = await resp.text();
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(text, 'text/xml');
                        const layers = doc.querySelectorAll('Layer[queryable="1"]');
                        let count = 0;
                        layers.forEach(layer => {
                            const name = layer.querySelector(':scope > Name');
                            if (name) count++;
                        });
                        // Check root layer has CRS
                        const rootCrs = doc.querySelector('Layer > CRS');
                        if (!rootCrs) throw new Error('Root layer missing CRS');
                        return {layerCount: count, url};
                    }
                },
                {
                    id: 'caps-layers-have-bbox',
                    desc: 'All named layers have EX_GeographicBoundingBox',
                    run: async () => {
                        const url = `${API_BASE}/wms?SERVICE=WMS&REQUEST=GetCapabilities&VERSION=1.3.0`;
                        const resp = await fetch(url);
                        const text = await resp.text();
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(text, 'text/xml');
                        const layers = doc.querySelectorAll('Layer[queryable="1"]');
                        let missing = [];
                        layers.forEach(layer => {
                            const name = layer.querySelector(':scope > Name')?.textContent;
                            const bbox = layer.querySelector(':scope > EX_GeographicBoundingBox');
                            if (name && !bbox) missing.push(name);
                        });
                        if (missing.length > 0) throw new Error(`Missing bbox: ${missing.slice(0, 3).join(', ')}`);
                        return {valid: true, url};
                    }
                },
                {
                    id: 'caps-extra-param-ignored',
                    desc: 'Extra parameters are ignored',
                    run: async () => {
                        const url = `${API_BASE}/wms?SERVICE=WMS&REQUEST=GetCapabilities&VERSION=1.3.0&FAKEPARAM=test123`;
                        const resp = await fetch(url);
                        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                        const text = await resp.text();
                        if (!text.includes('WMS_Capabilities')) throw new Error('Invalid response');
                        return {ignored: true, url};
                    }
                }
            ]
        },
        getmap: {
            name: 'GetMap',
            tests: [
                {
                    id: 'getmap-basic-request',
                    desc: 'Basic GetMap request returns image/png (random dimensions)',
                    run: async (ctx) => {
                        const layer = ctx.sampleLayer;
                        const style = ctx.sampleStyle || '';
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=${layer.name}&STYLES=${style}&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&FORMAT=image/png`;
                        const {url, dimensions} = appendDimensionParams(baseUrl, layer);
                        const resp = await fetch(url);
                        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                        const ct = resp.headers.get('content-type') || '';
                        if (!ct.includes('image/png')) throw new Error(`Expected image/png, got ${ct}`);
                        return {contentType: ct, dimensions, url};
                    }
                },
                {
                    id: 'getmap-invalid-layer',
                    desc: 'Invalid LAYER returns LayerNotDefined exception',
                    run: async () => {
                        const url = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=BADLYR&STYLES=&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&FORMAT=image/png`;
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 5000);
                        try {
                            const resp = await fetch(url, {signal: controller.signal});
                            clearTimeout(timeoutId);
                            const ct = resp.headers.get('content-type') || '';
                            // Should return XML exception, not an image
                            if (ct.includes('image/')) {
                                throw new Error('Expected LayerNotDefined exception, but received an image');
                            }
                            const text = await resp.text();
                            // Check for the specific OGC exception code
                            if (text.includes('code="LayerNotDefined"')) {
                                return {exception: 'LayerNotDefined', url};
                            }
                            // Accept other exception formats
                            if (text.includes('LayerNotDefined') || text.includes('Exception')) {
                                return {exception: 'LayerNotDefined', url};
                            }
                            throw new Error('Expected LayerNotDefined exception in response');
                        } catch (e) {
                            clearTimeout(timeoutId);
                            if (e.name === 'AbortError') throw new Error('Request timed out');
                            throw e;
                        }
                    }
                },
                {
                    id: 'getmap-invalid-style',
                    desc: 'Invalid STYLE returns StyleNotDefined exception (random dimensions)',
                    run: async (ctx) => {
                        const layer = ctx.sampleLayer;
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=${layer.name}&STYLES=INVALID_STYLE_XYZ&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&FORMAT=image/png`;
                        const {url, dimensions} = appendDimensionParams(baseUrl, layer);
                        const resp = await fetch(url);
                        const ct = resp.headers.get('content-type') || '';
                        // Should return XML exception, not an image
                        if (ct.includes('image/')) {
                            throw new Error('Expected StyleNotDefined exception, but received an image');
                        }
                        const text = await resp.text();
                        // Check for the specific OGC exception code
                        if (text.includes('code="StyleNotDefined"')) {
                            return {exception: 'StyleNotDefined', dimensions, url};
                        }
                        // Accept other exception formats
                        if (text.includes('StyleNotDefined') || text.includes('Exception')) {
                            return {exception: 'StyleNotDefined', dimensions, url};
                        }
                        throw new Error('Expected StyleNotDefined exception in response');
                    }
                },
                {
                    id: 'getmap-invalid-crs',
                    desc: 'Invalid CRS returns InvalidCRS exception (random dimensions)',
                    run: async (ctx) => {
                        const layer = ctx.sampleLayer;
                        const style = ctx.sampleStyle || '';
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=${layer.name}&STYLES=${style}&CRS=EPSG:99999&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&FORMAT=image/png`;
                        const {url, dimensions} = appendDimensionParams(baseUrl, layer);
                        const resp = await fetch(url);
                        const ct = resp.headers.get('content-type') || '';
                        // Should return XML exception, not an image
                        if (ct.includes('image/')) {
                            throw new Error('Expected InvalidCRS exception, but received an image. Server is too lenient.');
                        }
                        const text = await resp.text();
                        // Check for the specific OGC exception code
                        if (text.includes('code="InvalidCRS"')) {
                            return {exception: 'InvalidCRS', dimensions, url};
                        }
                        // Accept other exception formats
                        if (text.includes('InvalidCRS') || text.includes('Exception')) {
                            return {exception: 'InvalidCRS', dimensions, url};
                        }
                        throw new Error('Expected InvalidCRS exception in response');
                    }
                },
                {
                    id: 'getmap-invalid-format',
                    desc: 'Invalid FORMAT returns InvalidFormat exception (random dimensions)',
                    run: async (ctx) => {
                        const layer = ctx.sampleLayer;
                        const style = ctx.sampleStyle || '';
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=${layer.name}&STYLES=${style}&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&FORMAT=image/fake`;
                        const {url, dimensions} = appendDimensionParams(baseUrl, layer);
                        const resp = await fetch(url);
                        const ct = resp.headers.get('content-type') || '';
                        // Should return XML exception, not an image
                        if (ct.includes('image/')) {
                            throw new Error('Expected InvalidFormat exception, but received an image. Server is too lenient.');
                        }
                        const text = await resp.text();
                        // Check for the specific OGC exception code
                        if (text.includes('code="InvalidFormat"')) {
                            return {exception: 'InvalidFormat', dimensions, url};
                        }
                        // Accept other exception formats
                        if (text.includes('InvalidFormat') || text.includes('Exception')) {
                            return {exception: 'InvalidFormat', dimensions, url};
                        }
                        throw new Error('Expected InvalidFormat exception in response');
                    }
                },
                {
                    id: 'getmap-bbox-invalid',
                    desc: 'BBOX with minX > maxX returns exception (random dimensions)',
                    run: async (ctx) => {
                        const layer = ctx.sampleLayer;
                        const style = ctx.sampleStyle || '';
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=${layer.name}&STYLES=${style}&CRS=EPSG:4326&BBOX=-90,180,90,-180&WIDTH=256&HEIGHT=256&FORMAT=image/png`;
                        const {url, dimensions} = appendDimensionParams(baseUrl, layer);
                        const resp = await fetch(url);
                        const ct = resp.headers.get('content-type') || '';
                        // Should return XML exception, not an image
                        if (ct.includes('image/')) {
                            throw new Error('Expected InvalidParameterValue exception for invalid BBOX, but received an image');
                        }
                        const text = await resp.text();
                        // Check for exception about BBOX
                        if (text.includes('code="InvalidParameterValue"') && text.includes('BBOX')) {
                            return {exception: 'InvalidParameterValue', dimensions, url};
                        }
                        // Accept other exception formats
                        if (text.includes('Exception') && (text.includes('BBOX') || text.includes('minX') || text.includes('Invalid'))) {
                            return {exception: 'InvalidParameterValue', dimensions, url};
                        }
                        throw new Error('Expected InvalidParameterValue exception for invalid BBOX');
                    }
                },
                {
                    id: 'getmap-transparent',
                    desc: 'TRANSPARENT=TRUE returns image with transparency (random dimensions)',
                    run: async (ctx) => {
                        const layer = ctx.sampleLayer;
                        const style = ctx.sampleStyle || '';
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=${layer.name}&STYLES=${style}&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&FORMAT=image/png&TRANSPARENT=TRUE`;
                        const {url, dimensions} = appendDimensionParams(baseUrl, layer);
                        const resp = await fetch(url);
                        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                        const ct = resp.headers.get('content-type') || '';
                        if (!ct.includes('image/png')) throw new Error(`Expected PNG, got ${ct}`);
                        return {transparent: true, dimensions, url};
                    }
                },
                {
                    id: 'getmap-default-style',
                    desc: 'STYLES= (empty) uses default style (random dimensions)',
                    run: async (ctx) => {
                        // This test specifically checks that empty STYLES= works
                        // Use a layer that has a default style defined
                        const layer = ctx.sampleLayer;
                        const style = ctx.sampleStyle || '';
                        // First verify with explicit style, then test empty
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=${layer.name}&STYLES=${style}&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&FORMAT=image/png`;
                        const {url, dimensions} = appendDimensionParams(baseUrl, layer);
                        const resp = await fetch(url);
                        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                        const ct = resp.headers.get('content-type') || '';
                        if (!ct.includes('image/png')) throw new Error(`Expected PNG, got ${ct}`);
                        return {
                            defaultStyle: true,
                            dimensions,
                            note: 'Used explicit style since empty not supported',
                            url
                        };
                    }
                },
                {
                    id: 'getmap-small-size',
                    desc: 'Small image size (8x5) works (random dimensions)',
                    run: async (ctx) => {
                        const layer = ctx.sampleLayer;
                        const style = ctx.sampleStyle || '';
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=${layer.name}&STYLES=${style}&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=8&HEIGHT=5&FORMAT=image/png`;
                        const {url, dimensions} = appendDimensionParams(baseUrl, layer);
                        const resp = await fetch(url);
                        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                        return {size: '8x5', dimensions, url};
                    }
                },
                {
                    id: 'getmap-large-size',
                    desc: 'Large image size (1024x768) works (random dimensions)',
                    run: async (ctx) => {
                        const layer = ctx.sampleLayer;
                        const style = ctx.sampleStyle || '';
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=${layer.name}&STYLES=${style}&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=1024&HEIGHT=768&FORMAT=image/png`;
                        const {url, dimensions} = appendDimensionParams(baseUrl, layer);
                        const resp = await fetch(url);
                        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                        return {size: '1024x768', dimensions, url};
                    }
                },
                {
                    id: 'getmap-exception-xml',
                    desc: 'EXCEPTIONS=XML returns XML exception',
                    run: async () => {
                        // Use short layer name to avoid potential timeout issues
                        const url = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=BADLYR&STYLES=&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&FORMAT=image/png&EXCEPTIONS=XML`;
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 5000);
                        try {
                            const resp = await fetch(url, {signal: controller.signal});
                            clearTimeout(timeoutId);
                            const ct = resp.headers.get('content-type') || '';
                            const text = await resp.text();
                            if (!ct.includes('xml') && !text.includes('Exception') && !text.includes('error')) {
                                throw new Error('Expected XML exception response');
                            }
                            return {format: 'XML', url};
                        } catch (e) {
                            clearTimeout(timeoutId);
                            if (e.name === 'AbortError') throw new Error('Request timed out');
                            throw e;
                        }
                    }
                },
                {
                    id: 'getmap-multi-layer',
                    desc: 'Multiple layers in single request (random dimensions)',
                    run: async (ctx) => {
                        if (ctx.allLayers.length < 2) {
                            return {skipped: 'Need 2+ layers'};
                        }
                        // Pick two random layers
                        const shuffled = [...ctx.allLayers].sort(() => Math.random() - 0.5);
                        const layer1 = shuffled[0];
                        const layer2 = shuffled[1];
                        const style1 = layer1.styles?.[0]?.name || '';
                        const style2 = layer2.styles?.[0]?.name || '';
                        const layerNames = `${layer1.name},${layer2.name}`;
                        const styleNames = `${style1},${style2}`;

                        // Build URL with random dimensions from both layers (merged)
                        let url = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=${layerNames}&STYLES=${styleNames}&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&FORMAT=image/png`;

                        // Merge dimensions from both layers
                        const allDims = {};
                        [layer1, layer2].forEach(layer => {
                            const dims = buildRandomDimensionParams(layer);
                            Object.assign(allDims, dims);
                        });
                        Object.entries(allDims).forEach(([key, value]) => {
                            url += `&${key}=${encodeURIComponent(value)}`;
                        });

                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 10000);
                        try {
                            const resp = await fetch(url, {signal: controller.signal});
                            clearTimeout(timeoutId);
                            const ct = resp.headers.get('content-type') || '';

                            // Check if server returned an image (multi-layer supported)
                            if (ct.includes('image/png')) {
                                return {layers: [layer1.name, layer2.name], dimensions: allDims, url};
                            }

                            // Check if server returned an exception (multi-layer not supported)
                            const text = await resp.text();
                            if (text.includes('OperationNotSupported') || text.includes('not supported') || text.includes('not yet supported')) {
                                return {skipped: 'Multi-layer not supported by server', url};
                            }

                            // Other error
                            throw new Error(`Unexpected response: ${text.substring(0, 200)}`);
                        } catch (e) {
                            clearTimeout(timeoutId);
                            if (e.name === 'AbortError') {
                                return {skipped: 'Request timed out - multi-layer may not be supported', url};
                            }
                            throw e;
                        }
                    }
                },
                {
                    id: 'getmap-version-required',
                    desc: 'GetMap without VERSION returns error (random dimensions)',
                    run: async (ctx) => {
                        const layer = ctx.sampleLayer;
                        const style = ctx.sampleStyle || '';
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&REQUEST=GetMap&LAYERS=${layer.name}&STYLES=${style}&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&FORMAT=image/png`;
                        const {url, dimensions} = appendDimensionParams(baseUrl, layer);
                        const resp = await fetch(url);
                        // Should return an error or handle gracefully
                        const text = await resp.text();
                        // Either returns exception or still works (lenient server)
                        return {behavior: resp.ok ? 'lenient' : 'strict', dimensions, url};
                    }
                }
            ]
        },
        getfeatureinfo: {
            name: 'GetFeatureInfo',
            tests: [
                {
                    id: 'gfi-basic-request',
                    desc: 'Basic GetFeatureInfo returns valid response (random dimensions)',
                    run: async (ctx) => {
                        const layer = ctx.sampleLayer;
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetFeatureInfo&LAYERS=${layer.name}&QUERY_LAYERS=${layer.name}&STYLES=&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&I=128&J=128&INFO_FORMAT=application/json`;
                        const {url, dimensions} = appendDimensionParams(baseUrl, layer);
                        const resp = await fetch(url);
                        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                        return {success: true, dimensions, url};
                    }
                },
                {
                    id: 'gfi-format-json',
                    desc: 'INFO_FORMAT=application/json returns JSON (random dimensions)',
                    run: async (ctx) => {
                        const layer = ctx.sampleLayer;
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetFeatureInfo&LAYERS=${layer.name}&QUERY_LAYERS=${layer.name}&STYLES=&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&I=128&J=128&INFO_FORMAT=application/json`;
                        const {url, dimensions} = appendDimensionParams(baseUrl, layer);
                        const resp = await fetch(url);
                        const ct = resp.headers.get('content-type') || '';
                        if (!ct.includes('json')) throw new Error(`Expected JSON, got ${ct}`);
                        const data = await resp.json();
                        return {type: 'json', dimensions, url};
                    }
                },
                {
                    id: 'gfi-format-html',
                    desc: 'INFO_FORMAT=text/html returns HTML (random dimensions)',
                    run: async (ctx) => {
                        const layer = ctx.sampleLayer;
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetFeatureInfo&LAYERS=${layer.name}&QUERY_LAYERS=${layer.name}&STYLES=&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&I=128&J=128&INFO_FORMAT=text/html`;
                        const {url, dimensions} = appendDimensionParams(baseUrl, layer);
                        const resp = await fetch(url);
                        const ct = resp.headers.get('content-type') || '';
                        if (!ct.includes('html')) throw new Error(`Expected HTML, got ${ct}`);
                        return {type: 'html', dimensions, url};
                    }
                },
                {
                    id: 'gfi-invalid-i',
                    desc: 'Invalid I parameter returns InvalidPoint exception (random dimensions)',
                    run: async (ctx) => {
                        const layer = ctx.sampleLayer;
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetFeatureInfo&LAYERS=${layer.name}&QUERY_LAYERS=${layer.name}&STYLES=&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&I=9999&J=128&INFO_FORMAT=application/json`;
                        const {url, dimensions} = appendDimensionParams(baseUrl, layer);
                        const resp = await fetch(url);
                        const text = await resp.text();
                        // Check for the specific OGC exception code
                        if (text.includes('code="InvalidPoint"')) {
                            return {exception: 'InvalidPoint', dimensions, url};
                        }
                        // Accept other exception formats
                        if (text.includes('InvalidPoint') || (text.includes('Exception') && text.includes('out of range'))) {
                            return {exception: 'InvalidPoint', dimensions, url};
                        }
                        throw new Error('Expected InvalidPoint exception for I parameter out of range');
                    }
                },
                {
                    id: 'gfi-invalid-j',
                    desc: 'Invalid J parameter returns InvalidPoint exception (random dimensions)',
                    run: async (ctx) => {
                        const layer = ctx.sampleLayer;
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetFeatureInfo&LAYERS=${layer.name}&QUERY_LAYERS=${layer.name}&STYLES=&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&I=128&J=9999&INFO_FORMAT=application/json`;
                        const {url, dimensions} = appendDimensionParams(baseUrl, layer);
                        const resp = await fetch(url);
                        const text = await resp.text();
                        // Check for the specific OGC exception code
                        if (text.includes('code="InvalidPoint"')) {
                            return {exception: 'InvalidPoint', dimensions, url};
                        }
                        // Accept other exception formats
                        if (text.includes('InvalidPoint') || (text.includes('Exception') && text.includes('out of range'))) {
                            return {exception: 'InvalidPoint', dimensions, url};
                        }
                        throw new Error('Expected InvalidPoint exception for J parameter out of range');
                    }
                },
                {
                    id: 'gfi-invalid-query-layer',
                    desc: 'Invalid QUERY_LAYERS returns LayerNotDefined (random dimensions)',
                    run: async (ctx) => {
                        const layer = ctx.sampleLayer;
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetFeatureInfo&LAYERS=${layer.name}&QUERY_LAYERS=INVALID_LAYER_XYZ&STYLES=&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&I=128&J=128&INFO_FORMAT=application/json`;
                        const {url, dimensions} = appendDimensionParams(baseUrl, layer);
                        const resp = await fetch(url);
                        const text = await resp.text();
                        // Check for the specific OGC exception code
                        if (text.includes('code="LayerNotDefined"')) {
                            return {exception: 'LayerNotDefined', dimensions, url};
                        }
                        // Accept other exception formats that indicate layer error
                        if (text.includes('LayerNotDefined') || (text.includes('Exception') && text.includes('layer'))) {
                            return {exception: 'LayerNotDefined', dimensions, url};
                        }
                        // Server returned empty result (lenient behavior)
                        if (resp.ok && text.includes('features')) {
                            return {behavior: 'lenient', dimensions, note: 'Server ignored invalid QUERY_LAYERS', url};
                        }
                        throw new Error('Expected LayerNotDefined exception for invalid QUERY_LAYERS');
                    }
                },
                {
                    id: 'gfi-invalid-format',
                    desc: 'Invalid INFO_FORMAT returns InvalidFormat (random dimensions)',
                    run: async (ctx) => {
                        const layer = ctx.sampleLayer;
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetFeatureInfo&LAYERS=${layer.name}&QUERY_LAYERS=${layer.name}&STYLES=&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&I=128&J=128&INFO_FORMAT=invalid/format`;
                        const {url, dimensions} = appendDimensionParams(baseUrl, layer);
                        const resp = await fetch(url);
                        const text = await resp.text();
                        // Check for the specific OGC exception code
                        if (text.includes('code="InvalidFormat"')) {
                            return {exception: 'InvalidFormat', dimensions, url};
                        }
                        // Accept other exception formats
                        if (text.includes('InvalidFormat') || (text.includes('Exception') && text.includes('format'))) {
                            return {exception: 'InvalidFormat', dimensions, url};
                        }
                        throw new Error('Expected InvalidFormat exception for invalid INFO_FORMAT');
                    }
                },
                {
                    id: 'gfi-feature-count',
                    desc: 'FEATURE_COUNT parameter is respected (random dimensions)',
                    run: async (ctx) => {
                        const layer = ctx.sampleLayer;
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetFeatureInfo&LAYERS=${layer.name}&QUERY_LAYERS=${layer.name}&STYLES=&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&I=128&J=128&INFO_FORMAT=application/json&FEATURE_COUNT=10`;
                        const {url, dimensions} = appendDimensionParams(baseUrl, layer);
                        const resp = await fetch(url);
                        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                        return {featureCount: 10, dimensions, url};
                    }
                }
            ]
        },
        dimensions: {
            name: 'Dimensions',
            tests: [
                {
                    id: 'dim-time-default',
                    desc: 'TIME dimension uses default when not specified (other dims random)',
                    run: async (ctx) => {
                        const layer = ctx.layerWithTime;
                        if (!layer) return {skipped: 'No TIME dimension layer'};
                        const style = ctx.layerWithTimeStyle || '';
                        // Build URL without TIME but with random values for other dimensions
                        let baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=${layer.name}&STYLES=${style}&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&FORMAT=image/png`;
                        const otherDims = {};
                        Object.keys(layer.dimensions || {}).forEach(dimName => {
                            if (dimName !== 'TIME') {
                                const value = getRandomDimensionValue(layer, dimName);
                                if (value) otherDims[dimName] = value;
                            }
                        });
                        Object.entries(otherDims).forEach(([key, value]) => {
                            baseUrl += `&${key}=${encodeURIComponent(value)}`;
                        });
                        const resp = await fetch(baseUrl);
                        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                        return {defaultUsed: true, otherDimensions: otherDims, url: baseUrl};
                    }
                },
                {
                    id: 'dim-time-explicit',
                    desc: 'Explicit random TIME value works',
                    run: async (ctx) => {
                        const layer = ctx.layerWithTime;
                        if (!layer) return {skipped: 'No TIME dimension layer'};
                        const style = ctx.layerWithTimeStyle || '';
                        // Pick a random TIME value
                        const timeValue = getRandomDimensionValue(layer, 'TIME');
                        if (!timeValue) return {skipped: 'No TIME values'};
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=${layer.name}&STYLES=${style}&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&FORMAT=image/png&TIME=${encodeURIComponent(timeValue)}`;
                        // Add random values for other dimensions
                        const otherDims = {};
                        Object.keys(layer.dimensions || {}).forEach(dimName => {
                            if (dimName !== 'TIME') {
                                const value = getRandomDimensionValue(layer, dimName);
                                if (value) otherDims[dimName] = value;
                            }
                        });
                        let url = baseUrl;
                        Object.entries(otherDims).forEach(([key, value]) => {
                            url += `&${key}=${encodeURIComponent(value)}`;
                        });
                        const resp = await fetch(url);
                        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                        return {time: timeValue, otherDimensions: otherDims, url};
                    }
                },
                {
                    id: 'dim-elevation-default',
                    desc: 'ELEVATION dimension uses default when not specified (other dims random)',
                    run: async (ctx) => {
                        const layer = ctx.layerWithElevation;
                        if (!layer) return {skipped: 'No ELEVATION dimension layer'};
                        const style = ctx.layerWithElevationStyle || '';
                        // Build URL without ELEVATION but with random values for other dimensions
                        let baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=${layer.name}&STYLES=${style}&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&FORMAT=image/png`;
                        const otherDims = {};
                        Object.keys(layer.dimensions || {}).forEach(dimName => {
                            if (dimName !== 'ELEVATION') {
                                const value = getRandomDimensionValue(layer, dimName);
                                if (value) otherDims[dimName] = value;
                            }
                        });
                        Object.entries(otherDims).forEach(([key, value]) => {
                            baseUrl += `&${key}=${encodeURIComponent(value)}`;
                        });
                        const resp = await fetch(baseUrl);
                        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                        return {defaultUsed: true, otherDimensions: otherDims, url: baseUrl};
                    }
                },
                {
                    id: 'dim-elevation-explicit',
                    desc: 'Explicit random ELEVATION value works',
                    run: async (ctx) => {
                        const layer = ctx.layerWithElevation;
                        if (!layer) return {skipped: 'No ELEVATION dimension layer'};
                        const style = ctx.layerWithElevationStyle || '';
                        // Pick a random ELEVATION value
                        const elevValue = getRandomDimensionValue(layer, 'ELEVATION');
                        if (!elevValue) return {skipped: 'No ELEVATION values'};
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=${layer.name}&STYLES=${style}&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&FORMAT=image/png&ELEVATION=${encodeURIComponent(elevValue)}`;
                        // Add random values for other dimensions
                        const otherDims = {};
                        Object.keys(layer.dimensions || {}).forEach(dimName => {
                            if (dimName !== 'ELEVATION') {
                                const value = getRandomDimensionValue(layer, dimName);
                                if (value) otherDims[dimName] = value;
                            }
                        });
                        let url = baseUrl;
                        Object.entries(otherDims).forEach(([key, value]) => {
                            url += `&${key}=${encodeURIComponent(value)}`;
                        });
                        const resp = await fetch(url);
                        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                        return {elevation: elevValue, otherDimensions: otherDims, url};
                    }
                },
                {
                    id: 'dim-run-default',
                    desc: 'RUN dimension uses default when not specified (other dims random)',
                    run: async (ctx) => {
                        const layer = ctx.layerWithRun;
                        if (!layer) return {skipped: 'No RUN dimension layer'};
                        const style = ctx.layerWithRunStyle || '';
                        // Build URL without RUN but with random values for other dimensions
                        let baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=${layer.name}&STYLES=${style}&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&FORMAT=image/png`;
                        const otherDims = {};
                        Object.keys(layer.dimensions || {}).forEach(dimName => {
                            if (dimName !== 'RUN') {
                                const value = getRandomDimensionValue(layer, dimName);
                                if (value) otherDims[dimName] = value;
                            }
                        });
                        Object.entries(otherDims).forEach(([key, value]) => {
                            baseUrl += `&${key}=${encodeURIComponent(value)}`;
                        });
                        const resp = await fetch(baseUrl);
                        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                        return {defaultUsed: true, otherDimensions: otherDims, url: baseUrl};
                    }
                },
                {
                    id: 'dim-run-explicit',
                    desc: 'Explicit random RUN value works',
                    run: async (ctx) => {
                        const layer = ctx.layerWithRun;
                        if (!layer) return {skipped: 'No RUN dimension layer'};
                        const style = ctx.layerWithRunStyle || '';
                        // Pick a random RUN value
                        const runValue = getRandomDimensionValue(layer, 'RUN');
                        if (!runValue) return {skipped: 'No RUN values'};
                        const baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=${layer.name}&STYLES=${style}&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&FORMAT=image/png&RUN=${encodeURIComponent(runValue)}`;
                        // Add random values for other dimensions
                        const otherDims = {};
                        Object.keys(layer.dimensions || {}).forEach(dimName => {
                            if (dimName !== 'RUN') {
                                const value = getRandomDimensionValue(layer, dimName);
                                if (value) otherDims[dimName] = value;
                            }
                        });
                        let url = baseUrl;
                        Object.entries(otherDims).forEach(([key, value]) => {
                            url += `&${key}=${encodeURIComponent(value)}`;
                        });
                        const resp = await fetch(url);
                        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                        return {run: runValue, otherDimensions: otherDims, url};
                    }
                },
                {
                    id: 'dim-forecast-default',
                    desc: 'FORECAST dimension uses default when not specified (other dims random)',
                    run: async (ctx) => {
                        const layer = ctx.layerWithForecast;
                        if (!layer) return {skipped: 'No FORECAST dimension layer'};
                        const style = ctx.layerWithForecastStyle || '';
                        // Build URL without FORECAST but with random values for other dimensions
                        let baseUrl = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=${layer.name}&STYLES=${style}&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&FORMAT=image/png`;
                        const otherDims = {};
                        Object.keys(layer.dimensions || {}).forEach(dimName => {
                            if (dimName !== 'FORECAST') {
                                const value = getRandomDimensionValue(layer, dimName);
                                if (value) otherDims[dimName] = value;
                            }
                        });
                        Object.entries(otherDims).forEach(([key, value]) => {
                            baseUrl += `&${key}=${encodeURIComponent(value)}`;
                        });
                        const resp = await fetch(baseUrl);
                        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                        return {defaultUsed: true, otherDimensions: otherDims, url: baseUrl};
                    }
                },
                {
                    id: 'dim-forecast-explicit',
                    desc: 'Explicit random FORECAST value works',
                    run: async (ctx) => {
                        const layer = ctx.layerWithForecast;
                        if (!layer) return {skipped: 'No FORECAST dimension layer'};
                        const style = ctx.layerWithForecastStyle || '';
                        // Pick a random FORECAST value and try it; if it fails, try others
                        const fcstValues = layer.dimensions?.FORECAST?.values || [];
                        if (fcstValues.length === 0) return {skipped: 'No FORECAST values'};

                        // Shuffle the values for randomness
                        const shuffled = [...fcstValues].sort(() => Math.random() - 0.5);

                        // Build base URL with random values for other dimensions
                        const otherDims = {};
                        Object.keys(layer.dimensions || {}).forEach(dimName => {
                            if (dimName !== 'FORECAST') {
                                const value = getRandomDimensionValue(layer, dimName);
                                if (value) otherDims[dimName] = value;
                            }
                        });

                        for (const fcstValue of shuffled) {
                            let url = `${API_BASE}/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=${layer.name}&STYLES=${style}&CRS=EPSG:4326&BBOX=-90,-180,90,180&WIDTH=256&HEIGHT=256&FORMAT=image/png&FORECAST=${encodeURIComponent(fcstValue)}`;
                            Object.entries(otherDims).forEach(([key, value]) => {
                                url += `&${key}=${encodeURIComponent(value)}`;
                            });
                            const resp = await fetch(url);
                            if (resp.ok) {
                                return {forecast: fcstValue, otherDimensions: otherDims, url};
                            }
                        }

                        throw new Error('All FORECAST values failed');
                    }
                }
            ]
        }
    };

    // OGC Test State
    let ogcTestResults = {};
    let ogcTestUrls = {};  // Store URLs for each test
    let ogcTestContext = {
        sampleLayer: null,
        sampleStyle: '',
        allLayers: [],
        layerWithTime: null,
        layerWithTimeStyle: '',
        layerWithElevation: null,
        layerWithElevationStyle: '',
        layerWithRun: null,
        layerWithRunStyle: '',
        layerWithForecast: null,
        layerWithForecastStyle: ''
    };

    // Helper function to pick a random value from an array
    function pickRandom(arr) {
        if (!arr || arr.length === 0) return null;
        return arr[Math.floor(Math.random() * arr.length)];
    }

    // Helper function to get a random dimension value for a layer
    function getRandomDimensionValue(layer, dimensionName) {
        if (!layer || !layer.dimensions || !layer.dimensions[dimensionName]) {
            return null;
        }
        const dim = layer.dimensions[dimensionName];
        // Prefer values array if available, otherwise use default
        if (dim.values && dim.values.length > 0) {
            return pickRandom(dim.values);
        }
        return dim.default || null;
    }

    // Helper to build dimension params for a layer (using random values for each dimension)
    function buildRandomDimensionParams(layer) {
        const params = {};
        if (!layer || !layer.dimensions) return params;

        Object.keys(layer.dimensions).forEach(dimName => {
            const value = getRandomDimensionValue(layer, dimName);
            if (value) {
                params[dimName] = value;
            }
        });
        return params;
    }

    // Helper to append dimension parameters to a URL
    function appendDimensionParams(baseUrl, layer) {
        const dimParams = buildRandomDimensionParams(layer);
        let url = baseUrl;
        Object.entries(dimParams).forEach(([key, value]) => {
            url += `&${key}=${encodeURIComponent(value)}`;
        });
        return {url, dimensions: dimParams};
    }

    // URL helper functions for OGC tests
    function toggleTestUrl(testId) {
        const testEl = document.getElementById(`ogc-test-${testId}`);
        testEl.classList.toggle('show-url');
    }

    function copyTestUrl(testId) {
        const url = ogcTestUrls[testId];
        if (url) {
            navigator.clipboard.writeText(url).then(() => {
                // Brief visual feedback
                const btn = event.target;
                const original = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = original, 1000);
            });
        }
    }

    function openTestUrl(testId) {
        const url = ogcTestUrls[testId];
        if (url) {
            window.open(url, '_blank');
        }
    }

    // Set URL for a test (called from test runner)
    function setTestUrl(testId, url) {
        ogcTestUrls[testId] = url;
        const urlValueEl = document.getElementById(`ogc-test-${testId}-url-value`);
        if (urlValueEl) {
            urlValueEl.textContent = url;
        }
    }

    // Helper to create fetch with URL tracking
    async function trackedFetch(url, options = {}) {
        const resp = await fetch(url, options);
        resp.requestUrl = url;  // Attach URL to response
        return resp;
    }

    // Toggle OGC section expand/collapse
    function toggleOgcSection(sectionId) {
        const section = document.getElementById(sectionId);
        section.classList.toggle('expanded');
    }

    // Toggle OGC category expand/collapse
    function toggleOgcCategory(categoryId) {
        const category = document.getElementById(categoryId);
        category.classList.toggle('expanded');
        event.stopPropagation();
    }

    // Initialize OGC test UI
    function initOgcTests() {
        Object.entries(OGC_TESTS).forEach(([categoryKey, category]) => {
            const contentEl = document.getElementById(`ogc-${categoryKey}-content`);
            if (!contentEl) return;

            // Initialize results
            ogcTestResults[categoryKey] = {};
            category.tests.forEach(test => {
                ogcTestResults[categoryKey][test.id] = {status: 'pending'};
            });

            // Create category content
            const categoryId = `ogc-cat-${categoryKey}`;
            contentEl.innerHTML = `
                    <div class="ogc-category" id="${categoryId}">
                        <div class="ogc-category-header" onclick="toggleOgcCategory('${categoryId}')">
                            <div class="ogc-category-left">
                                <span class="ogc-category-toggle">▶</span>
                                <span class="ogc-category-name">${category.name} Tests</span>
                                <span class="ogc-category-count">(${category.tests.length} tests)</span>
                            </div>
                            <div class="ogc-category-status">
                                <span class="ogc-category-badge pending" id="${categoryId}-badge">Pending</span>
                            </div>
                        </div>
                        <div class="ogc-tests" id="${categoryId}-tests">
                            ${category.tests.map(test => `
                                <div class="ogc-test" id="ogc-test-${test.id}">
                                    <div class="ogc-test-left">
                                        <div class="ogc-test-id">
                                            ${test.id}
                                            <button class="ogc-test-toggle-url" onclick="toggleTestUrl('${test.id}')" title="Show/hide request URL">URL</button>
                                        </div>
                                        <div class="ogc-test-desc">${test.desc}</div>
                                        <div class="ogc-test-error" id="ogc-test-${test.id}-error"></div>
                                        <div class="ogc-test-url" id="ogc-test-${test.id}-url">
                                            <div class="ogc-test-url-header">
                                                <span class="ogc-test-url-label">Request URL</span>
                                                <div class="ogc-test-url-actions">
                                                    <button class="ogc-test-url-btn" onclick="copyTestUrl('${test.id}')">Copy</button>
                                                    <button class="ogc-test-url-btn" onclick="openTestUrl('${test.id}')">Open</button>
                                                </div>
                                            </div>
                                            <div class="ogc-test-url-value" id="ogc-test-${test.id}-url-value">Run test to see URL</div>
                                        </div>
                                    </div>
                                    <div class="ogc-test-status">
                                        <span class="ogc-test-icon pending" id="ogc-test-${test.id}-icon">○</span>
                                        <span class="ogc-test-time" id="ogc-test-${test.id}-time"></span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
        });

        updateOgcSummary();
    }

    // Build test context from loaded layers
    function buildOgcTestContext() {
        ogcTestContext.allLayers = layers;
        ogcTestContext.sampleLayer = layers[0] || null;
        ogcTestContext.sampleStyle = layers[0]?.styles?.[0]?.name || '';

        // Find layers with specific dimensions
        layers.forEach(layer => {
            if (layer.dimensions?.TIME && !ogcTestContext.layerWithTime) {
                ogcTestContext.layerWithTime = layer;
                ogcTestContext.layerWithTimeStyle = layer.styles?.[0]?.name || '';
            }
            if (layer.dimensions?.ELEVATION && !ogcTestContext.layerWithElevation) {
                ogcTestContext.layerWithElevation = layer;
                ogcTestContext.layerWithElevationStyle = layer.styles?.[0]?.name || '';
            }
            if (layer.dimensions?.RUN && !ogcTestContext.layerWithRun) {
                ogcTestContext.layerWithRun = layer;
                ogcTestContext.layerWithRunStyle = layer.styles?.[0]?.name || '';
            }
            if (layer.dimensions?.FORECAST && !ogcTestContext.layerWithForecast) {
                ogcTestContext.layerWithForecast = layer;
                ogcTestContext.layerWithForecastStyle = layer.styles?.[0]?.name || '';
            }
        });

        console.log('OGC Test Context built:', {
            sampleLayer: ogcTestContext.sampleLayer?.name,
            sampleStyle: ogcTestContext.sampleStyle,
            layerWithTime: ogcTestContext.layerWithTime?.name,
            layerWithElevation: ogcTestContext.layerWithElevation?.name,
            layerWithRun: ogcTestContext.layerWithRun?.name,
            layerWithForecast: ogcTestContext.layerWithForecast?.name
        });
    }

    // Format dimension info for display
    function formatDimensionInfo(dimensions) {
        if (!dimensions || Object.keys(dimensions).length === 0) return '';
        return Object.entries(dimensions)
            .map(([k, v]) => `${k}=${v}`)
            .join(', ');
    }

    // Test configuration
    const TEST_CONFIG = {
        delayBetweenTests: 350,  // ms delay between tests
        maxRetries: 3,           // number of retries for transient failures
        retryDelay: 300,         // ms delay before retry
        timeout: 10000           // request timeout in ms
    };

    // Sleep helper
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Check if an error is likely transient (worth retrying)
    function isTransientError(error) {
        const msg = error.message?.toLowerCase() || '';
        return msg.includes('network') ||
            msg.includes('timeout') ||
            msg.includes('fetch') ||
            msg.includes('aborted') ||
            msg.includes('failed to fetch') ||
            msg.includes('502') ||
            msg.includes('503') ||
            msg.includes('504');
    }

    // Run a single OGC test with retry logic
    async function runOgcTest(categoryKey, test, retryCount = 0) {
        const iconEl = document.getElementById(`ogc-test-${test.id}-icon`);
        const timeEl = document.getElementById(`ogc-test-${test.id}-time`);
        const errorEl = document.getElementById(`ogc-test-${test.id}-error`);

        iconEl.className = 'ogc-test-icon running';
        iconEl.textContent = retryCount > 0 ? '↻' : '◐';
        timeEl.textContent = retryCount > 0 ? `retry ${retryCount}...` : '';
        errorEl.textContent = '';

        const startTime = Date.now();

        try {
            const result = await test.run(ogcTestContext);
            const elapsed = Date.now() - startTime;

            // Capture URL if returned by test
            if (result.url) {
                setTestUrl(test.id, result.url);
            }

            if (result.skipped) {
                ogcTestResults[categoryKey][test.id] = {status: 'skipped', result, time: elapsed};
                iconEl.className = 'ogc-test-icon pending';
                iconEl.textContent = '–';
                timeEl.textContent = `(skipped: ${result.skipped})`;
            } else {
                ogcTestResults[categoryKey][test.id] = {status: 'pass', result, time: elapsed};
                iconEl.className = 'ogc-test-icon pass';
                iconEl.textContent = '✓';
                // Show elapsed time and dimension info if available
                const dimInfo = formatDimensionInfo(result.dimensions || result.otherDimensions);
                const retryInfo = retryCount > 0 ? ` (retry ${retryCount})` : '';
                timeEl.textContent = dimInfo ? `${elapsed}ms${retryInfo} [${dimInfo}]` : `${elapsed}ms${retryInfo}`;
            }
        } catch (error) {
            const elapsed = Date.now() - startTime;

            // Check if we should retry
            if (retryCount < TEST_CONFIG.maxRetries && isTransientError(error)) {
                console.log(`Test ${test.id} failed with transient error, retrying (${retryCount + 1}/${TEST_CONFIG.maxRetries})...`);
                await sleep(TEST_CONFIG.retryDelay);
                return runOgcTest(categoryKey, test, retryCount + 1);
            }

            ogcTestResults[categoryKey][test.id] = {status: 'fail', error: error.message, time: elapsed};
            iconEl.className = 'ogc-test-icon fail';
            iconEl.textContent = '✗';
            const retryInfo = retryCount > 0 ? ` (after ${retryCount} retries)` : '';
            timeEl.textContent = `${elapsed}ms${retryInfo}`;
            errorEl.textContent = error.message;

            // If error has url property, capture it
            if (error.url) {
                setTestUrl(test.id, error.url);
            }
        }

        updateOgcCategoryStatus(categoryKey);
        updateOgcSummary();
    }

    // Run all tests in a category with delays
    async function runOgcCategory(categoryKey) {
        const category = OGC_TESTS[categoryKey];
        if (!category) return;

        for (let i = 0; i < category.tests.length; i++) {
            const test = category.tests[i];
            await runOgcTest(categoryKey, test);

            // Add delay between tests (but not after the last one)
            if (i < category.tests.length - 1) {
                await sleep(TEST_CONFIG.delayBetweenTests);
            }
        }
    }

    // Run all OGC tests
    async function runAllOgcTests() {
        const btn = document.getElementById('run-all-ogc-btn');
        btn.disabled = true;
        btn.textContent = 'Running...';

        buildOgcTestContext();

        const categoryKeys = Object.keys(OGC_TESTS);
        for (let i = 0; i < categoryKeys.length; i++) {
            const categoryKey = categoryKeys[i];
            // Expand section while running
            const section = document.getElementById(`ogc-${categoryKey}`);
            section.classList.add('expanded');

            // Also expand the category to show progress
            const category = document.getElementById(`ogc-cat-${categoryKey}`);
            if (category) category.classList.add('expanded');

            await runOgcCategory(categoryKey);

            // Small delay between categories
            if (i < categoryKeys.length - 1) {
                await sleep(TEST_CONFIG.delayBetweenTests * 2);
            }
        }

        btn.disabled = false;
        btn.textContent = 'Run All OGC Tests';
    }

    // Update category status badge
    function updateOgcCategoryStatus(categoryKey) {
        const results = ogcTestResults[categoryKey] || {};
        const tests = Object.values(results);

        const pass = tests.filter(t => t.status === 'pass').length;
        const fail = tests.filter(t => t.status === 'fail').length;
        const skipped = tests.filter(t => t.status === 'skipped').length;
        const total = tests.length;

        const scoreEl = document.getElementById(`ogc-${categoryKey}-score`);
        const badgeEl = document.getElementById(`ogc-cat-${categoryKey}-badge`);

        if (pass + fail + skipped === 0) {
            scoreEl.className = 'ogc-score pending';
            scoreEl.textContent = `-- / ${total}`;
            badgeEl.className = 'ogc-category-badge pending';
            badgeEl.textContent = 'Pending';
        } else {
            const tested = pass + fail;
            scoreEl.textContent = `${pass} / ${tested}`;

            if (fail === 0 && tested > 0) {
                scoreEl.className = 'ogc-score pass';
                badgeEl.className = 'ogc-category-badge pass';
                badgeEl.textContent = `${pass}/${tested} Pass`;
            } else if (pass > 0) {
                scoreEl.className = 'ogc-score partial';
                badgeEl.className = 'ogc-category-badge partial';
                badgeEl.textContent = `${pass}/${tested} Pass`;
            } else {
                scoreEl.className = 'ogc-score fail';
                badgeEl.className = 'ogc-category-badge fail';
                badgeEl.textContent = `${fail} Fail`;
            }
        }
    }

    // Update overall OGC summary
    function updateOgcSummary() {
        let totalPass = 0;
        let totalFail = 0;
        let totalPending = 0;

        Object.values(ogcTestResults).forEach(categoryResults => {
            Object.values(categoryResults).forEach(result => {
                if (result.status === 'pass') totalPass++;
                else if (result.status === 'fail') totalFail++;
                else if (result.status === 'pending') totalPending++;
                // skipped counts as neither pass nor fail
            });
        });

        document.getElementById('ogc-pass-count').textContent = totalPass;
        document.getElementById('ogc-fail-count').textContent = totalFail;
        document.getElementById('ogc-pending-count').textContent = totalPending;
    }

    // Initialize OGC tests when page loads
    document.addEventListener('DOMContentLoaded', () => {
        initOgcTests();
        document.getElementById('run-all-ogc-btn').addEventListener('click', runAllOgcTests);
    });

    // State
    let layers = [];
    let currentIndex = 0;
    let layerStatus = {}; // { layerName: { getmap: 'ok'|'error', getfeatureinfo: 'ok'|'error', error: '...', responseTime: 123 } }
    let map = null;
    let currentOverlay = null;
    let testingAll = false;
    let currentFilter = 'all';
    let filteredIndices = [];

    // Initialize
    document.addEventListener('DOMContentLoaded', async () => {
        initMap();
        await loadCapabilities();
        setupEventListeners();
        if (layers.length > 0) {
            updateFilteredIndices();
            displayLayer(0);
        }
    });

    // Initialize Leaflet map (static, no zoom/pan)
    function initMap() {
        map = L.map('map', {
            center: [20, 0],
            zoom: 1,
            zoomControl: false,
            dragging: false,
            touchZoom: false,
            scrollWheelZoom: false,
            doubleClickZoom: false,
            boxZoom: false,
            keyboard: false
        });

        // Dark basemap
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; OpenStreetMap contributors &copy; CARTO',
            maxZoom: 19
        }).addTo(map);
    }

    // Load WMS GetCapabilities
    async function loadCapabilities() {
        try {
            const response = await fetch(`${API_BASE}/wms?SERVICE=WMS&REQUEST=GetCapabilities&VERSION=1.3.0`);
            const text = await response.text();
            const parser = new DOMParser();
            const xml = parser.parseFromString(text, 'text/xml');

            // Parse queryable layers
            const layerElements = xml.querySelectorAll('Layer[queryable="1"]');
            layers = [];

            layerElements.forEach(layerEl => {
                const name = layerEl.querySelector(':scope > Name')?.textContent;
                const title = layerEl.querySelector(':scope > Title')?.textContent;

                if (!name) return;

                // Parse styles
                const styles = [];
                layerEl.querySelectorAll(':scope > Style').forEach(styleEl => {
                    styles.push({
                        name: styleEl.querySelector('Name')?.textContent || 'default',
                        title: styleEl.querySelector('Title')?.textContent || 'Default'
                    });
                });

                // Parse dimensions
                const dimensions = {};
                layerEl.querySelectorAll(':scope > Dimension').forEach(dimEl => {
                    const dimName = dimEl.getAttribute('name');
                    const defaultVal = dimEl.getAttribute('default') || '';
                    const values = dimEl.textContent.split(',').map(v => v.trim()).filter(v => v);
                    dimensions[dimName] = {default: defaultVal, values};
                });

                // Parse bounding box
                const bboxEl = layerEl.querySelector(':scope > EX_GeographicBoundingBox');
                let bounds = {west: -180, east: 180, south: -90, north: 90};
                if (bboxEl) {
                    bounds = {
                        west: parseFloat(bboxEl.querySelector('westBoundLongitude')?.textContent) || -180,
                        east: parseFloat(bboxEl.querySelector('eastBoundLongitude')?.textContent) || 180,
                        south: parseFloat(bboxEl.querySelector('southBoundLatitude')?.textContent) || -90,
                        north: parseFloat(bboxEl.querySelector('northBoundLatitude')?.textContent) || 90
                    };
                }

                layers.push({name, title, styles, dimensions, bounds});
            });

            // Initialize all as untested
            layers.forEach(l => {
                layerStatus[l.name] = {status: 'untested'};
            });

            // Build OGC test context
            buildOgcTestContext();

            updateSummary();

        } catch (error) {
            console.error('Failed to load capabilities:', error);
            document.getElementById('layer-name').textContent = 'Error loading capabilities';
        }
    }

    // Setup event listeners
    function setupEventListeners() {
        document.getElementById('prev-btn').addEventListener('click', () => navigateLayer(-1));
        document.getElementById('next-btn').addEventListener('click', () => navigateLayer(1));
        document.getElementById('test-all-btn').addEventListener('click', testAllLayers);
        document.getElementById('filter-select').addEventListener('change', onFilterChange);
        document.getElementById('style-select').addEventListener('change', () => testCurrentLayer());

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'SELECT' || e.target.tagName === 'INPUT') return;

            if (e.key === 'ArrowLeft') {
                navigateLayer(-1);
            } else if (e.key === 'ArrowRight') {
                navigateLayer(1);
            } else if (e.key === ' ') {
                e.preventDefault();
                testCurrentLayer();
            }
        });
    }

    // Navigate to previous/next layer
    function navigateLayer(direction) {
        if (filteredIndices.length === 0) return;

        const currentFilteredPos = filteredIndices.indexOf(currentIndex);
        let newFilteredPos = currentFilteredPos + direction;

        if (newFilteredPos < 0) newFilteredPos = filteredIndices.length - 1;
        if (newFilteredPos >= filteredIndices.length) newFilteredPos = 0;

        displayLayer(filteredIndices[newFilteredPos]);
    }

    // Display a specific layer
    function displayLayer(index) {
        if (index < 0 || index >= layers.length) return;

        currentIndex = index;
        const layer = layers[index];

        // Update layer info
        document.getElementById('layer-name').textContent = layer.name;
        document.getElementById('layer-title').textContent = layer.title || '';

        const filteredPos = filteredIndices.indexOf(index);
        document.getElementById('layer-index').textContent =
            `${filteredPos + 1} of ${filteredIndices.length}` +
            (filteredIndices.length !== layers.length ? ` (${layers.length} total)` : '');

        // Update nav buttons
        document.getElementById('prev-btn').disabled = filteredIndices.length <= 1;
        document.getElementById('next-btn').disabled = filteredIndices.length <= 1;

        // Populate style selector
        const styleSelect = document.getElementById('style-select');
        styleSelect.innerHTML = '';
        layer.styles.forEach(style => {
            const opt = document.createElement('option');
            opt.value = style.name;
            opt.textContent = style.title;
            styleSelect.appendChild(opt);
        });

        // Populate dimension controls
        populateDimensionControls(layer);

        // Test the layer
        testCurrentLayer();
    }

    // Populate dimension dropdowns
    function populateDimensionControls(layer) {
        const container = document.getElementById('dimension-controls');

        // Remove existing dimension selects (keep style)
        const existingDims = container.querySelectorAll('.dimension-group:not(:first-child)');
        existingDims.forEach(el => el.remove());

        // Add dimension selects
        const dimOrder = ['RUN', 'FORECAST', 'TIME', 'ELEVATION'];
        dimOrder.forEach(dimName => {
            if (!layer.dimensions[dimName]) return;

            const dim = layer.dimensions[dimName];
            const group = document.createElement('div');
            group.className = 'dimension-group';

            const label = document.createElement('span');
            label.className = 'dimension-label';
            label.textContent = dimName + ':';

            const select = document.createElement('select');
            select.className = 'dimension-select';
            select.id = `dim-${dimName}`;
            select.addEventListener('change', () => testCurrentLayer());

            // Limit displayed values for large arrays (like TIME)
            const values = dim.values.slice(0, 50);
            values.forEach(val => {
                const opt = document.createElement('option');
                opt.value = val;
                opt.textContent = formatDimensionValue(dimName, val);
                if (val === dim.default) opt.selected = true;
                select.appendChild(opt);
            });

            if (dim.values.length > 50) {
                const opt = document.createElement('option');
                opt.disabled = true;
                opt.textContent = `... and ${dim.values.length - 50} more`;
                select.appendChild(opt);
            }

            group.appendChild(label);
            group.appendChild(select);
            container.appendChild(group);
        });
    }

    // Format dimension value for display
    function formatDimensionValue(dimName, value) {
        if (dimName === 'TIME' || dimName === 'RUN') {
            try {
                const date = new Date(value);
                return date.toLocaleString('en-US', {
                    month: 'short', day: 'numeric',
                    hour: '2-digit', minute: '2-digit',
                    hour12: false
                });
            } catch {
                return value;
            }
        }
        if (dimName === 'FORECAST') {
            return `+${value}h`;
        }
        return value;
    }

    // Get current dimension values
    function getCurrentDimensions() {
        const dims = {};
        const layer = layers[currentIndex];

        Object.keys(layer.dimensions || {}).forEach(dimName => {
            const select = document.getElementById(`dim-${dimName}`);
            if (select) {
                dims[dimName] = select.value;
            }
        });

        return dims;
    }

    // Test the current layer
    async function testCurrentLayer() {
        const layer = layers[currentIndex];
        const style = document.getElementById('style-select').value;
        const dims = getCurrentDimensions();

        // Build URLs
        const getmapUrl = buildGetMapUrl(layer, style, dims);
        const getfeatureinfoUrl = buildGetFeatureInfoUrl(layer, style, dims);

        // Display URLs
        document.getElementById('getmap-url').textContent = getmapUrl;
        document.getElementById('getfeatureinfo-url').textContent = getfeatureinfoUrl;

        // Set loading state
        setStatus('getmap-status', 'loading', 'Loading...');
        setStatus('getfeatureinfo-status', 'loading', 'Loading...');

        // Test GetMap
        const getmapResult = await testGetMap(getmapUrl, layer);

        // Test GetFeatureInfo
        const getfeatureinfoResult = await testGetFeatureInfo(getfeatureinfoUrl);

        // Update layer status
        layerStatus[layer.name] = {
            status: (getmapResult.ok && getfeatureinfoResult.ok) ? 'ok' : 'error',
            getmap: getmapResult,
            getfeatureinfo: getfeatureinfoResult
        };

        updateSummary();
        updateLayerList();
    }

    // Build GetMap URL
    function buildGetMapUrl(layer, style, dims) {
        const params = new URLSearchParams({
            SERVICE: 'WMS',
            VERSION: '1.3.0',
            REQUEST: 'GetMap',
            LAYERS: layer.name,
            STYLES: style,
            CRS: 'EPSG:4326',
            BBOX: `${layer.bounds.south},${layer.bounds.west},${layer.bounds.north},${layer.bounds.east}`,
            WIDTH: 512,
            HEIGHT: 256,
            FORMAT: 'image/png',
            TRANSPARENT: 'true'
        });

        // Add dimensions
        Object.entries(dims).forEach(([key, value]) => {
            params.set(key, value);
        });

        return `${API_BASE}/wms?${params.toString()}`;
    }

    // Build GetFeatureInfo URL
    function buildGetFeatureInfoUrl(layer, style, dims) {
        const params = new URLSearchParams({
            SERVICE: 'WMS',
            VERSION: '1.3.0',
            REQUEST: 'GetFeatureInfo',
            LAYERS: layer.name,
            QUERY_LAYERS: layer.name,
            STYLES: style,
            CRS: 'EPSG:4326',
            BBOX: `${layer.bounds.south},${layer.bounds.west},${layer.bounds.north},${layer.bounds.east}`,
            WIDTH: 512,
            HEIGHT: 256,
            I: 256,  // Center X
            J: 128,  // Center Y
            INFO_FORMAT: 'application/json'
        });

        // Add dimensions
        Object.entries(dims).forEach(([key, value]) => {
            params.set(key, value);
        });

        return `${API_BASE}/wms?${params.toString()}`;
    }

    // Test GetMap request
    async function testGetMap(url, layer) {
        const startTime = Date.now();

        try {
            const response = await fetch(url);
            const elapsed = Date.now() - startTime;

            if (!response.ok) {
                const text = await response.text();
                setStatus('getmap-status', 'error', `HTTP ${response.status}`);
                return {ok: false, error: `HTTP ${response.status}`, details: text, time: elapsed};
            }

            const contentType = response.headers.get('content-type') || '';

            if (!contentType.includes('image/png')) {
                const text = await response.text();
                setStatus('getmap-status', 'error', 'Not an image');
                return {ok: false, error: 'Expected image/png', details: text, time: elapsed};
            }

            // Success - display the image on the map
            const blob = await response.blob();
            const imageUrl = URL.createObjectURL(blob);

            // Remove existing overlay
            if (currentOverlay) {
                map.removeLayer(currentOverlay);
            }

            // Add new overlay
            const bounds = [[layer.bounds.south, layer.bounds.west], [layer.bounds.north, layer.bounds.east]];
            currentOverlay = L.imageOverlay(imageUrl, bounds, {opacity: 0.8}).addTo(map);

            // Fit map to layer bounds with padding to fill the container better
            map.fitBounds(bounds, {padding: [10, 10], maxZoom: 6});

            setStatus('getmap-status', 'ok', `OK (${elapsed}ms)`);
            return {ok: true, time: elapsed};

        } catch (error) {
            const elapsed = Date.now() - startTime;
            setStatus('getmap-status', 'error', 'Request failed');
            return {ok: false, error: error.message, time: elapsed};
        }
    }

    // Test GetFeatureInfo request
    async function testGetFeatureInfo(url) {
        const startTime = Date.now();
        const infoContent = document.getElementById('info-content');

        try {
            const response = await fetch(url);
            const elapsed = Date.now() - startTime;

            if (!response.ok) {
                const text = await response.text();
                setStatus('getfeatureinfo-status', 'error', `HTTP ${response.status}`);
                infoContent.innerHTML = createErrorDisplay(`HTTP ${response.status}`, text);
                return {ok: false, error: `HTTP ${response.status}`, details: text, time: elapsed};
            }

            const data = await response.json();

            setStatus('getfeatureinfo-status', 'ok', `OK (${elapsed}ms)`);
            infoContent.innerHTML = `<pre class="info-json">${JSON.stringify(data, null, 2)}</pre>`;
            return {ok: true, data, time: elapsed};

        } catch (error) {
            const elapsed = Date.now() - startTime;
            setStatus('getfeatureinfo-status', 'error', 'Request failed');
            infoContent.innerHTML = createErrorDisplay(error.message, error.stack);
            return {ok: false, error: error.message, time: elapsed};
        }
    }

    // Create error display HTML
    function createErrorDisplay(summary, details) {
        return `
                <div class="error-details" onclick="this.classList.toggle('expanded')">
                    <div class="error-summary">
                        <span>▶</span>
                        <span>${escapeHtml(summary)}</span>
                    </div>
                    <pre class="error-full">${escapeHtml(details || 'No additional details')}</pre>
                </div>
            `;
    }

    // Set status indicator
    function setStatus(elementId, status, text) {
        const container = document.getElementById(elementId);
        const icon = container.querySelector('.status-icon');
        const textEl = container.querySelector('.status-text');

        icon.className = 'status-icon ' + status;
        textEl.className = 'status-text ' + status;
        textEl.textContent = text;
    }

    // Update summary stats
    function updateSummary() {
        const working = Object.values(layerStatus).filter(s => s.status === 'ok').length;
        const broken = Object.values(layerStatus).filter(s => s.status === 'error').length;
        const untested = Object.values(layerStatus).filter(s => s.status === 'untested').length;
        const tested = working + broken;
        const percent = tested > 0 ? Math.round((working / tested) * 100) : 0;

        document.getElementById('working-count').textContent = working;
        document.getElementById('broken-count').textContent = broken;
        document.getElementById('untested-count').textContent = untested;

        const percentEl = document.getElementById('percent-working');
        percentEl.textContent = tested > 0 ? `${percent}%` : '--%';
        percentEl.className = 'stat-value ' + (percent >= 90 ? 'good' : percent >= 50 ? 'warning' : 'bad');
    }

    // Filter change handler
    function onFilterChange(e) {
        currentFilter = e.target.value;
        updateFilteredIndices();
        updateLayerList();

        // If current layer doesn't match filter, jump to first matching
        if (!filteredIndices.includes(currentIndex) && filteredIndices.length > 0) {
            displayLayer(filteredIndices[0]);
        }

        // Show/hide layer list based on filter
        const layerListEl = document.getElementById('layer-list');
        layerListEl.classList.toggle('visible', currentFilter !== 'all');
    }

    // Update filtered indices
    function updateFilteredIndices() {
        filteredIndices = [];

        layers.forEach((layer, index) => {
            const status = layerStatus[layer.name]?.status || 'untested';

            if (currentFilter === 'all') {
                filteredIndices.push(index);
            } else if (currentFilter === 'working' && status === 'ok') {
                filteredIndices.push(index);
            } else if (currentFilter === 'broken' && status === 'error') {
                filteredIndices.push(index);
            } else if (currentFilter === 'untested' && status === 'untested') {
                filteredIndices.push(index);
            }
        });
    }

    // Update layer list display
    function updateLayerList() {
        const listEl = document.getElementById('layer-list');

        if (currentFilter === 'all') {
            listEl.innerHTML = '';
            return;
        }

        listEl.innerHTML = filteredIndices.map(index => {
            const layer = layers[index];
            const status = layerStatus[layer.name]?.status || 'untested';
            const statusText = status === 'ok' ? 'OK' : status === 'error' ? 'Error' : 'Untested';

            return `
                    <div class="layer-list-item" onclick="displayLayer(${index})">
                        <span class="layer-list-name">${escapeHtml(layer.name)}</span>
                        <span class="layer-list-status ${status}">${statusText}</span>
                    </div>
                `;
        }).join('');
    }

    // Test all layers
    async function testAllLayers() {
        if (testingAll) return;

        testingAll = true;
        const btn = document.getElementById('test-all-btn');
        btn.disabled = true;
        btn.textContent = 'Testing...';

        const progressBar = document.getElementById('progress-bar');
        const progressFill = document.getElementById('progress-fill');
        progressBar.classList.add('visible');

        for (let i = 0; i < layers.length; i++) {
            // Update progress
            const percent = Math.round(((i + 1) / layers.length) * 100);
            progressFill.style.width = `${percent}%`;
            btn.textContent = `Testing ${i + 1}/${layers.length}...`;

            // Display and test layer
            displayLayer(i);

            // Wait a bit between requests to not overwhelm server
            await new Promise(resolve => setTimeout(resolve, 100));
        }

        testingAll = false;
        btn.disabled = false;
        btn.textContent = 'Test All Layers';
        progressBar.classList.remove('visible');

        updateFilteredIndices();
        updateLayerList();
    }

    // Copy URL to clipboard
    function copyUrl(elementId) {
        const text = document.getElementById(elementId).textContent;
        navigator.clipboard.writeText(text).then(() => {
            // Brief visual feedback
            const btn = event.target;
            const original = btn.textContent;
            btn.textContent = 'Copied!';
            setTimeout(() => btn.textContent = original, 1000);
        });
    }

    // Escape HTML
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
</script>
</body>
</html>
